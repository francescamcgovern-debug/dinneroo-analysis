#!/usr/bin/env python3
"""
Sync Dish Data Script

Generates dish_data.js from priority_100_unified.json to keep the dashboard in sync.

This script bridges the gap between:
- docs/data/priority_100_unified.json (generated by regenerate_dish_scores_v3_1.py)
- docs/dish_data.js (consumed by dashboard HTML)

Usage:
    python3 scripts/sync_dish_data.py

Run this after:
    python3 scripts/phase2_analysis/regenerate_dish_scores_v3_1.py
"""

import json
from datetime import datetime
from pathlib import Path

# Paths
PROJECT_ROOT = Path(__file__).parent.parent
SOURCE_JSON = PROJECT_ROOT / "docs" / "data" / "priority_100_unified.json"
OUTPUT_JS = PROJECT_ROOT / "docs" / "dish_data.js"


def load_dish_data():
    """Load the dish prioritization JSON."""
    if not SOURCE_JSON.exists():
        print(f"✗ Source not found: {SOURCE_JSON}")
        print("  Run: python3 scripts/phase2_analysis/regenerate_dish_scores_v3_1.py first")
        return None
    
    with open(SOURCE_JSON, 'r') as f:
        data = json.load(f)
    
    return data


def generate_dish_data_js(data: dict) -> str:
    """Generate JavaScript file content from dish data."""
    
    dishes = data.get("dishes", [])
    framework_version = data.get("framework_version", "3.1")
    tier_distribution = data.get("tier_distribution", {})
    quadrant_distribution = data.get("quadrant_distribution", {})
    
    # Count key metrics for header
    on_dinneroo = len([d for d in dishes if d.get("on_dinneroo")])
    off_dinneroo = len([d for d in dishes if not d.get("on_dinneroo")])
    
    # Generate JS content with embedded data
    js_content = f"""// Dish prioritization data - {len(dishes)} dishes ({on_dinneroo} on Dinneroo, {off_dinneroo} prospects)
// Auto-generated from docs/data/priority_100_unified.json
// Framework: v{framework_version}
// Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
// DO NOT EDIT MANUALLY - Run: python3 scripts/sync_dish_data.py

const dishDataEmbedded = {{
    "framework_version": "{framework_version}",
    "generated": "{datetime.now().isoformat()}",
    "total_dishes": {len(dishes)},
    "tier_distribution": {json.dumps(tier_distribution)},
    "quadrant_distribution": {json.dumps(quadrant_distribution)},
    "dishes": {json.dumps(dishes, indent=2)}
}};
"""
    
    return js_content


def main():
    print("=" * 60)
    print("SYNCING DISH DATA")
    print(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)
    print()
    
    # Load source data
    print(f"Loading: {SOURCE_JSON.name}")
    data = load_dish_data()
    
    if data is None:
        return False
    
    dishes = data.get("dishes", [])
    on_dinneroo = len([d for d in dishes if d.get("on_dinneroo")])
    off_dinneroo = len([d for d in dishes if not d.get("on_dinneroo")])
    
    print(f"  ✓ Loaded {len(dishes)} dishes ({on_dinneroo} on Dinneroo, {off_dinneroo} prospects)")
    print(f"  ✓ Framework version: {data.get('framework_version', 'unknown')}")
    print()
    
    # Generate JS content
    print("Generating dish_data.js...")
    js_content = generate_dish_data_js(data)
    js_size_kb = len(js_content) / 1024
    print(f"  ✓ Generated {js_size_kb:.1f} KB")
    print()
    
    # Write to docs directory
    print(f"Writing: {OUTPUT_JS}")
    with open(OUTPUT_JS, 'w') as f:
        f.write(js_content)
    print(f"  ✓ Written to docs/")
    
    print()
    print("=" * 60)
    print("SYNC COMPLETE")
    print("=" * 60)
    print()
    print("Files updated:")
    print(f"  • {OUTPUT_JS.relative_to(PROJECT_ROOT)}")
    print()
    print("Data summary:")
    print(f"  • Total dishes: {len(dishes)}")
    print(f"  • On Dinneroo: {on_dinneroo}")
    print(f"  • Prospects (not on Dinneroo): {off_dinneroo}")
    
    tier_dist = data.get("tier_distribution", {})
    print(f"  • Tier distribution:")
    for tier, count in sorted(tier_dist.items()):
        print(f"    - {tier}: {count}")
    
    print()
    
    return True


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)


